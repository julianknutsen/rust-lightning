/// Abstraction for the transport layer as described by Bolt #8 [https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md]

use bitcoin::secp256k1::{SecretKey, PublicKey};

use ln::peers::conduit::Conduit;
use ln::peers::handler::{ITransport, PayloadQueuer};
use ln::peers::handshake::PeerHandshake;
use ln::wire;
use ln::wire::Encode;

use util::ser::{Writeable, VecWriter};

/// Interface used by Transport to interact with a handshake object
pub(super) trait IPeerHandshake {
	/// Instantiate a new outbound handshake
	fn new_outbound(initiator_static_private_key: &SecretKey, responder_static_public_key: &PublicKey, initiator_ephemeral_private_key: &SecretKey) -> Self;

	/// Set up the handshake receiving any bytes that need to be sent to the peer
	fn set_up_outbound(&mut self) -> Vec<u8>;

	/// Instantiate a new inbound handshake
	fn new_inbound(responder_static_private_key: &SecretKey, responder_ephemeral_private_key: &SecretKey) -> Self;

	/// Progress the handshake given bytes received from the peer. Returns Some(Conduit, PublicKey) when the handshake
	/// is complete.
	fn process_act(&mut self, input: &[u8]) -> Result<(Option<Vec<u8>>, Option<(Conduit, PublicKey)>), String>;
}

pub(super) struct Transport<PeerHandshakeImpl: IPeerHandshake=PeerHandshake> {
	pub(super) conduit: Option<Conduit>,
	handshake: PeerHandshakeImpl,
	pub(super) their_node_id: Option<PublicKey>,
}

impl<PeerHandshakeImpl: IPeerHandshake> ITransport for Transport<PeerHandshakeImpl> {
	fn new_outbound(initiator_static_private_key: &SecretKey, responder_static_public_key: &PublicKey, initiator_ephemeral_private_key: &SecretKey) -> Self {
		Self {
			conduit: None,
			handshake: PeerHandshakeImpl::new_outbound(initiator_static_private_key, responder_static_public_key, initiator_ephemeral_private_key),
			their_node_id: None,
		}
	}

	fn set_up_outbound(&mut self) -> Vec<u8> {
		self.handshake.set_up_outbound().to_vec()
	}

	fn new_inbound(responder_static_private_key: &SecretKey, responder_ephemeral_private_key: &SecretKey) -> Self {
		Self {
			conduit: None,
			handshake: PeerHandshakeImpl::new_inbound(responder_static_private_key, responder_ephemeral_private_key),
			their_node_id: None,
		}
	}

	fn process_input(&mut self, input: &[u8], output_buffer: &mut impl PayloadQueuer) -> Result<(), String> {
		match self.conduit {
			// Continue handshake
			None => {
				let (response_option, conduit_and_remote_pubkey_option) = self.handshake.process_act(input)?;

				// Any response generated by the handshake sequence is put into the response buffer
				if let Some(response) = response_option {
					output_buffer.push_back(response.to_vec());
				}

				// If handshake is complete change the state
				if let Some((conduit, remote_pubkey)) = conduit_and_remote_pubkey_option {
					self.conduit = Some(conduit);
					self.their_node_id = Some(remote_pubkey);
				}
			}
			Some(ref mut conduit) => {
				conduit.read(input);
			}
		};

		Ok(())
	}

	fn is_connected(&self) -> bool {
		self.conduit.is_some()
	}

	fn enqueue_message<M: Encode + Writeable, Q: PayloadQueuer>(&mut self, message: &M, output_buffer: &mut Q) {
		match self.conduit {
			None => panic!("Enqueueing messages only supported after transport is connected"),
			Some(ref mut conduit) => {
				let mut buffer = VecWriter(Vec::new());
				wire::write(message, &mut buffer).unwrap();
				output_buffer.push_back(conduit.encrypt(&buffer.0));
			}
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use ln::peers::test_util::*;

	use bitcoin::secp256k1;
	use bitcoin::secp256k1::key::{PublicKey, SecretKey};
	use ln::msgs;

	fn create_outbound_for_test<PeerHandshakeImpl: IPeerHandshake>() -> Transport<PeerHandshakeImpl> {
		let curve = secp256k1::Secp256k1::new();
		let outbound_static_private_key = SecretKey::from_slice(&[0x_11_u8; 32]).unwrap();
		let outbound_ephemeral_private_key = SecretKey::from_slice(&[0x_12_u8; 32]).unwrap();
		let inbound_static_private_key = SecretKey::from_slice(&[0x_21_u8; 32]).unwrap();
		let inbound_static_public_key = PublicKey::from_secret_key(&curve, &inbound_static_private_key);

		Transport::<PeerHandshakeImpl>::new_outbound(&outbound_static_private_key, &inbound_static_public_key, &outbound_ephemeral_private_key)
	}

	fn create_inbound_for_test<PeerHandshakeImpl: IPeerHandshake>() -> Transport<PeerHandshakeImpl> {
		let inbound_static_private_key = SecretKey::from_slice(&[0x_21_u8; 32]).unwrap();
		let inbound_ephemeral_private_key = SecretKey::from_slice(&[0x_22_u8; 32]).unwrap();

		Transport::<PeerHandshakeImpl>::new_inbound(&inbound_static_private_key, &inbound_ephemeral_private_key)
	}

	// Test initial states start off unconnected
	#[test]
	fn inbound_unconnected() {
		let transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();

		assert!(!transport.is_connected());
	}

	#[test]
	fn outbound_unconnected() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		transport.set_up_outbound();

		assert!(!transport.is_connected());
	}

	// Test that errors in the handshake code are reraised through the transport
	#[test]
	fn inbound_handshake_error_reraises() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy).err(), Some("Oh no!".to_string()));
	}

	#[test]
	fn outbound_handshake_error_reraises() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy).err(), Some("Oh no!".to_string()));
	}

	#[test]
	fn inbound_handshake_data_goes_to_queue() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubBytes>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(!transport.is_connected());

		assert_matches!(&spy[..], [_]);
	}

	// Test that data returned from the in-progress handshake code makes it through to the outbound buffer
	#[test]
	fn outbound_handshake_data_goes_to_queue() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubBytes>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(!transport.is_connected());

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn inbound_handshake_complete_ready_for_encryption() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(transport.is_connected());
	}

	// Test that when a handshake completes is_connected() is correct
	#[test]
	fn outbound_handshake_complete_ready_for_encryption() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(transport.is_connected());
	}

	#[test]
	#[should_panic(expected = "Enqueueing messages only supported after transport is connected")]
	fn inbound_enqueue_message_panic() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy);
	}

	// Test that enqueue_message() panics in the wrong state
	#[test]
	#[should_panic(expected = "Enqueueing messages only supported after transport is connected")]
	fn outbound_enqueue_message_panic() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy);
	}

	// Test that enqueue_message() puts something into the outbound buffer
	#[test]
	fn inbound_enqueue_message_encrypts() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy);

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn outbound_enqueue_message_encrypts() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy);

		assert_matches!(&spy[..], [_]);
	}
}