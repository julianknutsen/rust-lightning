/// Abstraction for the transport layer as described by Bolt #8 [https://github.com/lightningnetwork/lightning-rfc/blob/master/08-transport.md]

use bitcoin::secp256k1::{SecretKey, PublicKey};

use ln::peers::conduit::Conduit;
use ln::peers::handler::{ITransport, PeerHandleError, PayloadQueuer};
use ln::peers::handshake::PeerHandshake;
use ln::{wire, msgs};
use ln::wire::{Encode, Message};

use util::ser::{Writeable, VecWriter};
use util::logger::Logger;
use std::ops::Deref;

/// Interface used by Transport to interact with a handshake object
pub(super) trait IPeerHandshake {
	/// Instantiate a new outbound handshake
	fn new_outbound(initiator_static_private_key: &SecretKey, responder_static_public_key: &PublicKey, initiator_ephemeral_private_key: &SecretKey) -> Self;

	/// Set up the handshake receiving any bytes that need to be sent to the peer
	fn set_up_outbound(&mut self) -> Vec<u8>;

	/// Instantiate a new inbound handshake
	fn new_inbound(responder_static_private_key: &SecretKey, responder_ephemeral_private_key: &SecretKey) -> Self;

	/// Progress the handshake given bytes received from the peer. Returns Some(Conduit, PublicKey) when the handshake
	/// is complete.
	fn process_act(&mut self, input: &[u8]) -> Result<(Option<Vec<u8>>, Option<(Conduit, PublicKey)>), String>;
}

pub(super) struct Transport<PeerHandshakeImpl: IPeerHandshake=PeerHandshake> {
	pub(super) conduit: Option<Conduit>,
	handshake: PeerHandshakeImpl,
	pub(super) their_node_id: Option<PublicKey>,
}

impl<PeerHandshakeImpl: IPeerHandshake> ITransport for Transport<PeerHandshakeImpl> {
	fn new_outbound(initiator_static_private_key: &SecretKey, responder_static_public_key: &PublicKey, initiator_ephemeral_private_key: &SecretKey) -> Self {
		Self {
			conduit: None,
			handshake: PeerHandshakeImpl::new_outbound(initiator_static_private_key, responder_static_public_key, initiator_ephemeral_private_key),
			their_node_id: None,
		}
	}

	fn set_up_outbound(&mut self) -> Vec<u8> {
		self.handshake.set_up_outbound().to_vec()
	}

	fn new_inbound(responder_static_private_key: &SecretKey, responder_ephemeral_private_key: &SecretKey) -> Self {
		Self {
			conduit: None,
			handshake: PeerHandshakeImpl::new_inbound(responder_static_private_key, responder_ephemeral_private_key),
			their_node_id: None,
		}
	}

	fn process_input(&mut self, input: &[u8], output_buffer: &mut impl PayloadQueuer) -> Result<(), String> {
		match self.conduit {
			// Continue handshake
			None => {
				let (response_option, conduit_and_remote_pubkey_option) = self.handshake.process_act(input)?;

				// Any response generated by the handshake sequence is put into the response buffer
				if let Some(response) = response_option {
					output_buffer.push_back(response.to_vec());
				}

				// If handshake is complete change the state
				if let Some((conduit, remote_pubkey)) = conduit_and_remote_pubkey_option {
					self.conduit = Some(conduit);
					self.their_node_id = Some(remote_pubkey);
				}
			}
			Some(ref mut conduit) => {
				conduit.read(input);
			}
		};

		Ok(())
	}

	fn drain_messages<L: Deref>(&mut self, logger: L) -> Result<Vec<Message>, PeerHandleError>
		where L::Target: Logger {

		let mut received_messages = vec![];

		match self.conduit {
			None => {}
			Some(ref mut conduit) => {
				// Using Iterators that can error requires special handling
				// The item returned from next() has type Option<Result<Option<Vec>, String>>
				// The Some wrapper is stripped for each item inside the loop
				// There are 3 valid match cases:
				// 1) Some(Ok(Some(msg_data))) => Indicates a valid decrypted msg accessed via msg_data
				// 2) Some(Err(_)) => Indicates an error during decryption that should be handled
				// 3) None -> Indicates there were no messages available to decrypt
				// Invalid Cases
				// 1) Some(Ok(None)) => Translated to None case above so users of iterators can stop correctly
				for msg_data_result in &mut conduit.decryptor {
					match msg_data_result {
						Ok(Some(msg_data)) => {
							let mut reader = ::std::io::Cursor::new(&msg_data[..]);
							let message_result = wire::read(&mut reader);
							let message = match message_result {
								Ok(x) => x,
								Err(e) => {
									match e {
										msgs::DecodeError::UnknownVersion => return Err(PeerHandleError { no_connection_possible: false }),
										msgs::DecodeError::UnknownRequiredFeature => {
											log_debug!(logger, "Got a channel/node announcement with an known required feature flag, you may want to update!");
											continue;
										}
										msgs::DecodeError::InvalidValue => {
											log_debug!(logger, "Got an invalid value while deserializing message");
											return Err(PeerHandleError { no_connection_possible: false });
										}
										msgs::DecodeError::ShortRead => {
											log_debug!(logger, "Deserialization failed due to shortness of message");
											return Err(PeerHandleError { no_connection_possible: false });
										}
										msgs::DecodeError::BadLengthDescriptor => return Err(PeerHandleError { no_connection_possible: false }),
										msgs::DecodeError::Io(_) => return Err(PeerHandleError { no_connection_possible: false }),
									}
								}
							};

							received_messages.push(message);
						},
						Err(e) => {
							log_trace!(logger, "Message decryption failed due to: {}", e);
							return Err(PeerHandleError { no_connection_possible: false });
						}
						Ok(None) => {
							panic!("Invalid behavior. Conduit iterator should never return this match.")
						}
					}
				}
			}
		}

		Ok(received_messages)
	}

	fn is_connected(&self) -> bool {
		self.conduit.is_some()
	}

	fn enqueue_message<M: Encode + Writeable, Q: PayloadQueuer, L: Deref>(&mut self, message: &M, output_buffer: &mut Q, logger: L)
		where L::Target: Logger {

		match self.conduit {
			None => panic!("Enqueueing messages only supported after transport is connected"),
			Some(ref mut conduit) => {
				log_trace!(logger, "Enqueueing message of type {} to {}", message.type_id(), log_pubkey!(self.their_node_id.unwrap()));

				let mut buffer = VecWriter(Vec::new());
				wire::write(message, &mut buffer).unwrap();
				output_buffer.push_back(conduit.encrypt(&buffer.0));
			}
		}
	}
}

#[cfg(test)]
mod tests {
	use super::*;
	use ln::peers::test_util::*;

	use bitcoin::secp256k1;
	use bitcoin::secp256k1::key::{PublicKey, SecretKey};
	use ln::msgs;
	use util::test_utils::TestLogger;

	fn create_outbound_for_test<PeerHandshakeImpl: IPeerHandshake>() -> Transport<PeerHandshakeImpl> {
		let curve = secp256k1::Secp256k1::new();
		let outbound_static_private_key = SecretKey::from_slice(&[0x_11_u8; 32]).unwrap();
		let outbound_ephemeral_private_key = SecretKey::from_slice(&[0x_12_u8; 32]).unwrap();
		let inbound_static_private_key = SecretKey::from_slice(&[0x_21_u8; 32]).unwrap();
		let inbound_static_public_key = PublicKey::from_secret_key(&curve, &inbound_static_private_key);

		Transport::<PeerHandshakeImpl>::new_outbound(&outbound_static_private_key, &inbound_static_public_key, &outbound_ephemeral_private_key)
	}

	fn create_inbound_for_test<PeerHandshakeImpl: IPeerHandshake>() -> Transport<PeerHandshakeImpl> {
		let inbound_static_private_key = SecretKey::from_slice(&[0x_21_u8; 32]).unwrap();
		let inbound_ephemeral_private_key = SecretKey::from_slice(&[0x_22_u8; 32]).unwrap();

		Transport::<PeerHandshakeImpl>::new_inbound(&inbound_static_private_key, &inbound_ephemeral_private_key)
	}

	// Test initial states start off unconnected
	#[test]
	fn inbound_unconnected() {
		let transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();

		assert!(!transport.is_connected());
	}

	#[test]
	fn outbound_unconnected() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		transport.set_up_outbound();

		assert!(!transport.is_connected());
	}

	// Test that errors in the handshake code are reraised through the transport
	#[test]
	fn inbound_handshake_error_reraises() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubFail>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy).err(), Some("Oh no!".to_string()));
	}

	#[test]
	fn outbound_handshake_error_reraises() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubFail>();
		let mut spy = Vec::new();

		assert_eq!(transport.process_input(&[], &mut spy).err(), Some("Oh no!".to_string()));
	}

	#[test]
	fn inbound_handshake_data_goes_to_queue() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubBytes>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(!transport.is_connected());

		assert_matches!(&spy[..], [_]);
	}

	// Test that data returned from the in-progress handshake code makes it through to the outbound buffer
	#[test]
	fn outbound_handshake_data_goes_to_queue() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubBytes>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(!transport.is_connected());

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn inbound_handshake_complete_ready_for_encryption() {
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(transport.is_connected());
	}

	// Test that when a handshake completes is_connected() is correct
	#[test]
	fn outbound_handshake_complete_ready_for_encryption() {
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();
		assert!(transport.is_connected());
	}

	#[test]
	#[should_panic(expected = "Enqueueing messages only supported after transport is connected")]
	fn inbound_enqueue_message_panic() {
		let logger = TestLogger::new();
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);
	}

	// Test that enqueue_message() panics in the wrong state
	#[test]
	#[should_panic(expected = "Enqueueing messages only supported after transport is connected")]
	fn outbound_enqueue_message_panic() {
		let logger = TestLogger::new();
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);
	}

	// Test that enqueue_message() puts something into the outbound buffer
	#[test]
	fn inbound_enqueue_message_encrypts() {
		let logger = TestLogger::new();
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn outbound_enqueue_message_encrypts() {
		let logger = TestLogger::new();
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();
		let mut spy = Vec::new();

		transport.process_input(&[], &mut spy).unwrap();

		let ping = msgs::Ping {
			ponglen: 0,
			byteslen: 64,
		};
		transport.enqueue_message(&ping, &mut spy, &logger);

		assert_matches!(&spy[..], [_]);
	}

	#[test]
	fn inbound_not_connected_empty() {
		let logger = TestLogger::new();
		let mut transport = create_inbound_for_test::<PeerHandshakeTestStubComplete>();

		let messages = transport.drain_messages(&logger).unwrap();
		assert_eq!(messages.len(), 0);
	}

	#[test]
	fn outbound_not_connected_empty() {
		let logger = TestLogger::new();
		let mut transport = create_outbound_for_test::<PeerHandshakeTestStubComplete>();

		let messages = transport.drain_messages(&logger).unwrap();
		assert_eq!(messages.len(), 0);
	}

	// TODO: Backfill connected tests of drain_messages()

}